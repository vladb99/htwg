00002000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 08.06.2020 15:28:49

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Aufgabe01
00000000                             3  * Written by : Vlad Bratulescu - 299874
00000000                             4  * Date       : 02.06.2020
00000000                             5  * Description: Erste Aufgabe in REAR Übung
00000000                             6  *-----------------------------------------------------------
00002000                             7      ORG     $2000           ; Anfang vom Objektcode
00002000                             8  START:
00002000  43F9 00002500              9      LEA     ANFANG, A1      
00002006  45F9 00002800             10      LEA     RESULT, A2
0000200C  47F9 00002810             11      LEA     ERGEB,  A3      ; Adressen jeweils in den Adressregistern laden
00002012                            12         
00002012  3039 0000205A             13      MOVE.W  K1,     D0      
00002018  3239 0000205C             14      MOVE.W  K2,     D1      ; K1 und K2 in D0 und D1 laden
0000201E  D240                      15      ADD.W   D0,     D1      ; D0 mit D1 addieren und Ergebnis in D1 speichern
00002020  32C1                      16      MOVE.W  D1,     (A1)+   ; D1 in die Adresse schieben, auf die A1 zeigt. Danach wird A1 um eine Speicherzelle inkrementiert
00002022                            17  
00002022  4282                      18      CLR.L   D2              ; Feld für Summe aller Speicherzellen initialisieren
00002024  D441                      19      ADD.W   D1,     D2      ; D1 drauf addieren
00002026                            20      
00002026  363C 00C7                 21      MOVE.W  #199,   D3      ; Laufvariable für die Schleife initialisieren
0000202A                            22      
0000202A                            23  LOOP:                       ; for (i = 199; i >= 0; i--)
0000202A  5241                      24      ADD.W   #1,     D1      ; D1 um 1 inkrementieren
0000202C  D481                      25      ADD.L   D1,     D2      ; D2 mit D1 addieren um die Gesamtsumme aller Speicherzellen zu bilden
0000202E  32C1                      26      MOVE.W  D1,     (A1)+   ; D1 in die Adresse schieben, auf die A1 zeigt. Danach wird A1 um eine Speicherzelle inkrementiert
00002030  5343                      27      SUB.W   #1,     D3      ; Die Laufvariable um 1 dekrementieren
00002032  6AF6                      28      BPL     LOOP            ; Wenn der N-Bit nicht gesetzt wurde, springe nach LOOP
00002034                            29  
00002034  2482                      30      MOVE.L  D2,     (A2)    ; Am Schluss soll die Gesamtsumme aller Speicherzellen an der Adresse RESULT abgelegt werden
00002036  43F9 00002500             31      LEA     ANFANG, A1      ; Adresse ANFANG nochmal in A1 laden
0000203C                            32  
0000203C  363C 0063                 33      MOVE.W  #99,    D3      ; Laufvariable für die zweite Schleife initialisieren
00002040  4281                      34      CLR.L   D1              ; D1 löschen
00002042                            35      
00002042                            36  MOD2:
00002042  4280                      37      CLR.L   D0              ; D0 löschen
00002044  3019                      38      MOVE.W  (A1)+,  D0      ; Den Inhalt von der Adresse auf die A1 zeigt, wird in D0 geladen
00002046  80FC 0002                 39      DIVU    #2,     D0      ; D0 durch zwei teilen. Der Quotient wird im Lower-Word und der Rest im Higher-Word gespeichert.
0000204A  4240                      40      CLR.W   D0              ; Quotient löschen
0000204C  4840                      41      SWAP    D0              ; Higher-Word mit Lower-Word tauschen, also den Rest der Division im Lower-Byte schieben
0000204E  6600 0004                 42      BNE     SKIP            ; Springe wenn D0 nicht 0 ist
00002052  5241                      43      ADD.W   #1,     D1      ; Inkrementiere D1 um 1
00002054                            44  SKIP:
00002054  5343                      45      SUB.W   #1,     D3      ; Subtrahiere 1 vom D3
00002056  6AEA                      46      BPL     MOD2            ; Springe wenn nicht negativ
00002058  1681                      47      MOVE.B  D1,     (A3)    ; Anzahl der ohne Rest durch 2 teilbaren Zahlen in ERGEB schieben
0000205A                            48              
0000205A                            49          
0000205A  =00002500                 50  ANFANG  EQU     $2500
0000205A  =00002800                 51  RESULT  EQU     $2800
0000205A  =00002810                 52  ERGEB   EQU     $2810       ;Symbolische Adressen initialisieren
0000205A                            53  
0000205A= 2000                      54  K1      DC.W    $2000       ; Konstante K1 wird definiert
0000205C= 4000                      55  K2      DC.W    $4000       ; Konstante K2 wird definiert
0000205E                            56  
0000205E                            57       END    START        

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ANFANG              2500
ERGEB               2810
K1                  205A
K2                  205C
LOOP                202A
MOD2                2042
RESULT              2800
SKIP                2054
START               2000
